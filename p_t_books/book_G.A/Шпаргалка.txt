1.Шпаргалка

Линейное время - O(n), Логорефмическое время O(log n).

• Бинарный поиск работает намного быстрее простого.

• Время выполнения O(log n) быстрее O(n), а с увеличением размера списка, в котором ищется значение, оно становится намного быстрее.

• Скорость алгоритмов не измеряется в секундах.

• Время выполнения алгоритма описывается ростом количества операций.

• Время выполнения алгоритмов выражается как «O-большое».

2.Шпаргалка
• Память компьютера напоминает огромный шкаф с ящиками.

• Если вам потребуется сохранить набор элементов, воспользуйтесь массивом или списком.

• В массиве все элементы хранятся в памяти рядом друг с другом.

• В списке элементы распределяются в произвольных местах памяти, при этом в одном элементе хранится адрес следующего элемента.

• Массивы обеспечивают быстрое чтение.

• Списки обеспечивают быструю вставку и выполнение.

• Все элементы массива должны быть однотипными (только целые числа, только вещественные числа и т.д.).

3.Шпаргалка
• Когда функция вызывает саму себя, это называется рекурсией.

• В каждой рекурсивной функции должно быть два случая: базовый и рекурсивный.

• Стек поддерживает две операции: занесение и извлечение элементов.

• Все вызовы функций сохраняются в стеке вызовов.

• Если стек вызовов станет очень большим, он займет слишком много памяти.

4.Шпаргалка
• Стратегия «разделяй и властвуй» основана на разбиении задачи на уменьшающиеся фрагменты. Если вы используете стратегию «разделяй и властвуй» со списком, то базовым случаем, скорее всего, является пустой массив или массив из одного элемента.

• Если вы реализуете алгоритм быстрой сортировки, выберите в качестве опорного случайный элемент. Среднее время выполнения быстрой сор­тировки составляет O(n log n)!

• Константы в «O-большом» иногда могут иметь значение. Именно по этой причине быстрая сортировка быстрее сортировки слиянием.

• При сравнении простой сортировки с бинарной константа почти никогда роли не играет, потому что O(log n) слишком сильно превосходит O(n) по скорости при большом размере списка.

5.Шпаргалка
Хеши хорошо подходят для решения следующих задач:

• моделирование отношений между объектами;

• устранение дубликатов;

• кэширование/запоминание данных вместо выполнения работы на сервере.

5.1.Шпаргалка
Вам почти никогда не придется реализовать хеш-таблицу самостоятельно. Язык программирования, который вы используете, должен предоставить необходимую реализацию. Вы можете пользоваться хеш-таблицами Python, и при этом вам будет обеспечена производительность среднего случая: постоянное время.

Хеш-таблицы чрезвычайно полезны, потому что они обеспечивают высокую скорость операций и позволяют по-разному моделировать данные. Возможно, вскоре выяснится, что вы постоянно используете их в своей работе.

• Хеш-таблица создается объединением хеш-функции с массивом.

• Коллизии нежелательны. Хеш-функция должна свести количество коллизий к минимуму.

• Хеш-таблицы обеспечивают очень быстрое выполнение поиска, вставки и удаления.

• Хеш-таблицы хорошо подходят для моделирования отношений между объектами.

• Как только коэффициент заполнения превышает 0,7, пора изменять размер хеш-таблицы.

• Хеш-таблицы используются для кэширования данных (например, на веб-серверах).

• Хеш-таблицы хорошо подходят для обнаружения дубликатов.

6.Шпаргалка
• Поиск в ширину позволяет определить, существует ли путь из A в B.

• Если путь существует, то поиск в ширину находит кратчайший путь.

• Если в вашей задаче требуется найти «кратчайшее X», попробуйте смоделировать свою задачу графом и воспользуйтесь поиском в ширину для ее решения.

• В направленном графе есть стрелки, а отношения действуют в направлении стрелки (Рама —> Адит означает «Рама должен Адиту»).

• В ненаправленных графах стрелок нет, а отношение идет в обе стороны (Росс – Рэйчел означает «Росс встречается с Рэйчел, а Рэйчел встречается с Россом».)

• Очереди относятся к категории FIFO («первым вошел, первым вышел»).

• Стек относится к категории LIFO («последним пришел, первым вышел»).

• Людей следует проверять в порядке их добавления в список поиска, поэтому список поиска должен быть оформлен в виде очереди, иначе найденный путь не будет кратчайшим.

• Позаботьтесь о том, чтобы уже проверенный человек не проверялся заново, иначе может возникнуть бесконечный цикл.

7.Шпаргалка
• Поиск в ширину вычисляет кратчайший путь в невзвешенном графе.

• Алгоритм Дейкстры вычисляет кратчайший путь во взвешенном графе.

• Алгоритм Дейкстры работает только в том случае, если все веса положительны.

• При наличии отрицательных весов используйте алгоритм Беллмана—Форда.

8.Шпаргалка
• Жадные алгоритмы стремятся к локальной оптимизации в расчете на то, что в итоге будет достигнут глобальный оптимум.

• У NP-полных задач не существует известных быстрых решений.

• Если у вас имеется NP-полная задача, лучше всего воспользоваться приближенным алгоритмом.

• Жадные алгоритмы легко реализуются и быстро выполняются, поэтому из них получаются хорошие приближенные алгоритмы.

9.Шпаргалка
• Динамическое программирование применяется при оптимизации некоторой характеристики.

• Динамическое программирование работает только в ситуациях, в которых задача может быть разбита на автономные подзадачи.

• В каждом решении из области динамического программирования строится таблица.

• Значения ячеек таблицы обычно соответствуют оптимизируемой характеристике.

• Каждая ячейка представляет подзадачу, поэтому вы должны подумать о том, как разбить задачу на подзадачи.

• Не существует единой формулы для вычисления решений методом динамического программирования.

10.