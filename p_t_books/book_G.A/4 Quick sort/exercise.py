#4.1
def sum(arr):
    if not arr:
        return 0
    else:
        return arr[0] + sum(arr[1:])

print(sum([1, 2, 3, 4]))  # Выведет: 10

#4.2
def count_elements(arr):
    if not arr:
        return 0
    else:
        return 1 + count_elements(arr[1:])

print(count_elements([1, 2, 3, 4]))  # Выведет: 4

#4.3
def max_number(arr):
    if len(arr) == 1:
        return arr[0]
    else:
        return max(arr[0], max_number(arr[1:]))

print(max_number([1, 2, 7, 4, 3]))  # Выведет: 7

#4.4
'''Бинарный поиск основан на принципе "разделяй и властвуй". Базовый случай возникает, когда размер массива становится равным 0 или 1. Рекурсивный случай заключается в том, что массив делится пополам и происходит поиск в одной из половин.

Базовый случай:
Если массив пустой, то возвращается "не найдено".
Если массив состоит из одного элемента, то проверяется, равен ли этот элемент ключу поиска.

Рекурсивный случай:
Если ключ поиска меньше элемента в середине массива, то поиск выполняется в левой половине массива.
Если ключ поиска больше элемента в середине массива, то поиск выполняется в правой половине массива.
Если ключ поиска равен элементу в середине массива, то элемент найден.'''

'''
4.5 Вывод значения каждого элемента массива: O(n)
4.6 Удвоение значения каждого элемента массива: O(n)
4.7 Удвоение значения только первого элемента массива: O(1)
4.8 Создание таблицы умножения для всех элементов массива: O(n^2)
'''